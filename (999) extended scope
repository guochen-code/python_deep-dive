closure means extended scope
func.__closure__
func.__code__.co_freevars
********************************************************************************************************************************************************************
shared extended scopes (shared free variable)

def outer():
  count=0
  
  def inc1():
    nonlocal count
    count+=1
    return count
  
  def inc2():
    nonlocal count
    count +=1
    return count
  
  return inc1, inc2
  
f1,f2=outer()
f1() ->1
f2() ->2

************************************************** problem online
def adder(n):
  def inner(x):
    return x+n
  return inner
add_1=adder(1)
add_2=adder(2)
add_3=adder(3)

add_1(10) ->11
add_2(10) ->12
add_2(10) ->13

But suppose we doing it this way:
adders=[]
for n in range(1,4):
  adders.append(lambda x:x+n)
  
n=1: the free variable in the lambda is n, and it is bound to the n we created in the loop
n=2: the free variable in the lambda is n, and it is bound to the (same) n we created in the loop
n=1: the free variable in the lambda is n, and it is bound to the (same) n we created in the loop

now we could call the adders in the following way:
adders[0](10) -> 13
adders[1](10) -> 13
adders[2](10) -> 13

# note that: adders->[<function __main__.<lambda>(x)>, <function __main__.<lambda>(x)>, <function __main__.<lambda>(x)>]
# reason:
remember python does not "evaluate" the free variable n until the adders[i] function is called
since all three functions in adders are bound to the same n
by the time we call adders[0], the value of n is 3 (the last iteration of the loop set n to 3)
