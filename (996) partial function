higher order function, because take function as a parameter.

reducing function arguments

def my_func(a,b,c):
  print(a,b,c)

def fn(b,c):
  return my_func(10,b,c)

fn(20,30) -> 10, 20, 30

f = lambda b,c: my_func(10,b,c)

******************************************************************************************************************************
from functools import partial
f=partial(my_func,10)
f(20,30) -> 10, 20, 30

handling more complex arguments
example:
def my_func(a,b,*args,k1,k2,**kwargs):
  print(a,b,args,k1,k2,kwargs)

def f(b,*args,k2,**kwargs):
  return my_func(10,b,*args,k1='a',k2=k2,**kwargs)

f=partial(my_func,10,k1='a')

Beware!!!
you can use variables when creating partials, but there arises a similar issue to argument default values
******** it is defined only during the definition time *********
example:
def my_func(a,b,c):
  print(a,b,c)

a=10
f=partial(my_func,a)
f(20,30) -> 10, 20, 30

a=100
f(20,30) -> 10, 20, 30 # a now points to a different memory address, but the partial still points to the original object (10) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

if a is mutable (e.g. a list), then it's contents can be changed. ==== list.append()
