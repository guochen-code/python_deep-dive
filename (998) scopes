built-in scope -> module/global scope -> local scope (inside function)

global and local scoping
when python encounters a function definition at compile-time. It will scan for any labels(variables) that have values assigne to them (anywhere in the function)
if the label has not been specified as gloabl, then it will be local
variables that are referenced but not assigned a value anywhere in the function will not be local, and python will, at run-time, look for them in enclosing scopes.
********************************************************************************************************************************************
module1.py
print(True) -> True
# python does not find True or print in the current (module/global) scope. so it look for them in the enclosing scope - built-in and find them there

module2.py
print(a) -> error
# python does not find a or print in the current (module/global) scope. so it looks for them in the enclosing scope - built-in. Find print, but not a

module3.py
print=lambda x:'hello{0}!'.format(x)
s=print('world') -> hello world!
# python finds print in the module scope. so it uses it! overwrite built-in print function.
********************************************************************************************************************************************
varibale defined inside of a fuction are not created until the function is called

example:
a=0
def my_func():
  a=100
  print(a)
my_func() -> 100 # need to call function to activate all these things
!!!!!!!!!!!!!!!!!!!!!!  after the function run, the local scope is cleaned up and gone !!!!!!!!!!!!!!!!!!!!! so
print(a) -> 0


example: # change global variable from local scope
a=0
def my_func():
  global= a
  a=100
my_func() # need to call function to activate all these things
print(a) -> 100

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ tricky ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
a =10
def func4():
  print(a) -> when we call func4(), print(a) results in a run-time error
  a=100

assignment at compile time -> a local

at compile time, python see an assignment. at the time the function runs, a exists, in the name space, hasn't been assigned value though.
we assign value in the second line of code.
we try to refer it before we assign a value
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
